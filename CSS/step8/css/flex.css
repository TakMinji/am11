/* 
★flex 제외 float, grid.. 같은 속성들은 자손들끼리 정렬하는 것. 오히려 부모를 망가뜨림

<flex 특징>
flex는 자손들끼리 알아서 하는 타입이 아님 
기본은 부모가 배치시키는 방법(부모가 내리는 것)
한번 붙으면 안떨어짐(물론 떨어지게 바꿀 순 있음. 반응형에서 어려워짐)
(=/float는 반응형에서 쉽다. 반면 flex는 어렵다.)

flex는 부모가 뭔짓거리를 하든 자손 안떨어짐
>> 사용이 편하나 계산 잘못해도 티가 안나고 근거가 없기때문에 수정에 어렵다는 단점.

* flex는 떨어뜨려야하는 구조가 있다면 퍼센트(%)보다 픽셀(px)을 많이씀.
*/

.flexContainer{
    margin: 10px; padding: 15px; border-radius: 23px; background-color: #a4a4a4;
    display: flex;
}
.test{
    background-color: #a4a4a4; width: 48%; box-sizing: border-box; border-radius: 23px;
    display: inline-flex;
}
.flexContainer .flexItem,
.test a{
    margin: 10px; padding: 20px; color: white; text-align: center; border-radius: 27px;
    background-color: black;
}
.flexContainer.direction{
    flex-direction: row-reverse;
    /* 
    스위치1. direction)
    flex-direction: row; (default값) 
    column-reverse / row-reverse : float나 inline-block이 못하는 순서가 바뀌는 것을 해냄 
    */
}
.flexContainer.wrap{
    flex-wrap: wrap-reverse; flex-direction: row-reverse;
    /* 
    스위치2. wrap)
    flex-wrap: nowrap; (defalt값. 부모가 줄어들어도 애들은 뚫고나감) 
    wrap : 감싸다. float는 못하나 inline-block은 가능
    wrap-reverser : 오른쪽에 있는 것부터 위로 올라감
    */
}
.flexContainer.flow{
    flex-flow: row wrap;
    /* 
    스위치2. flow) direction과 wrap을 숏앤드로 쓸 수 있는 속성
    direction과 wrap속성을 먼저 정하고 사용함
    direction, wrap 순서로 씀
    */
}
.flexContainer.flow .flexItem{
    width: 500px;
}
.flexContainer.justifyContent{
    justify-content: space-around; padding: 0;
}
/* 
justify-content )
space-between : 부모경계 좌우밀착 / 개수의 -1로 나눠서 배분함
space-evenly : 부모의 경계선까지 포함시켜서 균등하게 배분함
space-around : 위 두개를 섞은 것 / 초기의 1번하고 5번하고 부모사이의 간격을 일정하게 두되,
일정하게 둔 간격은 항목간 간격과 일치하지않음. 부모경계선에 닿지않는 상태에서 최대한 넓은 공간에 위차하고 싶을 때 씀.
*/
    /*
        justify-content : 
        flex container의 main axis를 기준으로 flexItem을 수평(or수직) 정렬한다.
        
        flex-start (flexItem을 좌측 기준정렬)
        flex-end (flexItem을 우측 기준정렬)
        center (flexItem을 가운데 기준정렬)
        space-between (flexItem 중 처음은 좌측기준, 마지막은 우측기준, 나머지는 동일간격으로 정렬)
        space-around (모든 flexItem은 처음,마지막 사이를  동일간격으로 정렬 외 나머지 배치)
        space-evenly (여유 공간을 flex 항목 사이의 공간 및 시작선 및 끝선과 flex 항목 간의 공간에 모두 균등하게 배분.)
    */
.flexContainer.justifyContent .flexItem{
    margin: 0;
}
/* 
우리입장에서 start는 기본위치(왼쪽이자 위) / and는 반대(오른쪽, 아래)
원래는 x,y축이 정해져있지만 flex입장에선 영원한 x,y가 없음
(direction의 row-revece, column-reverce 속성과 관련됨) 
flex 공간배치에서는 justify(left,right),align(top,bottom) / stat,end로 통일


! justify, align의 flex 배치방법)
content : 부모를 기준으로 자손을 배치
items: 자손들끼리 배치(상대적으로 제일 안씀.  float나 inline-block에서 할 수 있기때문에)
self : 자기 혼자 배치(치트키)
*/

.flexContainer.alignContent{
    height: 400px; flex-wrap: wrap; padding: 0;
    align-content: space-between; justify-content: flex-end;
}
/* 
flex-wrap :nowrap 이면 alignContent작동안됨 
align-content: flex-start(상), center(중), flex-end(하);
*/

.flexContainer.alignContent .flexItem{
    width: 300px; margin: 0;
}
    /* 
        ! align(yAxis)
        align-content: (창조절필요)
        flex container의 cross axis를 기준으로 flexItem을 수직 정렬한다.
        
        stretch (flexItem 행 간격을 균등하게. cross Start에서 End까지 꽉찬 높이.)
        flex-start (flexItem 행 간격 없이 (stack))
        flex-end (flexContainer의 cross end 기준으로 행 간격 없이)
        center (flexContainer의 cross axis 중앙 기준으로 행 간격 없이)
        space-between (첫 행은 flexContainer cross start 기준, 마지막 행은 flexContainer cross end 기준, 나머지 행 균등하게)
        space-around (모든 flexItem은 처음,마지막 사이를  동일간격으로 정렬 외 나머지 배치)
        space-evenly (여유 공간을 flex 항목 사이의 공간 및 시작선 및 끝선과 flex 항목 간의 공간에 모두 균등하게 배분.) 
    */

.flexContainer.alignItems{
    align-items: baseline;
    /* align-items : baseline >> 안에 있는 컨텐츠 라인(밑선) 기준으로 정렬하는 것 */
    background-color: orange;
}
.flexContainer.alignItems:hover{
    align-items: flex-start;
    /* 
    flex-start : 자기들끼리중 가장 높은 애
    flex-end : 자기들끼리중 가장 낮은 애 기준으로 잡는 것 
    */
}
.flexContainer.alignItems .flexItem:first-of-type{
    line-height: 50px;
}
.flexContainer.alignItems .flexItem:nth-of-type(2){
    line-height: 100px;
}
.flexContainer.justifyItems{
    display: grid; background-color: yellow; width: 300px;
    justify-items: flex-start;
}
.flexContainer.justifyItems:hover{
    justify-items: flex-end;
}
.flexContainer.justifyItems .flexItem{
    margin: 1px;
}
.flexContainer.alignSelf .flexItem:first-of-type{
    line-height: 100px;
}
.flexContainer.alignSelf .flexItem:nth-of-type(2){
    align-self: flex-end;
}
/* 
    ?align-self
    * stretch - 요소들중 가장 높은 것을 기준으로 자신의 높이를 맞추기
    * flex-start - 요소들중 가장 높은 것의 윗선을 기준으로 자신을 맞추기
    * flex-end - 요소들중 가장 높은 것의 밑선을 기준으로 자신을 맞추기
*/
.flexContainer.justifySelf{
    width: 220px; display: grid;
}
.flexContainer.justifySelf .flexItem:first-of-type{
    justify-self: flex-end;
}
.flexContainer.justifySelf:hover .flexItem:first-of-type{
    justify-self: flex-start;
}
/* 
    ?justify-self
    * stretch - 내부 공간 기준으로 자신의 너비 맞추기
    * flex-start - 내부 공간 기준으로 자신의 위치를 좌측으로 맞추기
    * flex-end - 내부 공간 기준으로 자신의 위치를 우측으로 맞추기
*/

.flexContainer.orderItem .flexItem.order1{
    order: 4;
}
.flexContainer.orderItem .flexItem.order2{
    order: 3;
}
.flexContainer.orderItem .flexItem.order3{
    order: 2;
}
.flexContainer.orderItem .flexItem:nth-of-type(4){
    order: 1;
}
.flexContainer.orderItem .flexItem:nth-of-type(5){
    order: 0;
}
/* 
order 순서를 바꾸는 것
0이 defualt값
기존수치보다 order수치가 적어지면 우선으로 오게될 수 있음.
기존수치보다 커지면 우선권을 잃고 뒤로감
*/

.flexContainer.flexShortHand{
    width: 50%; margin: 0; padding: 0; 
    /* ? shrink(수축비) text */
    max-width: 300px;
}
.flexContainer.flexShortHand .flexItem{
    margin: 0; padding: 0; word-break: break-all;
}
.flexContainer.flexShortHand .flexItem:first-child{
    /* flex-grow: 2; flex-basis: 0; */
    flex-shrink: 2; flex-basis: 150px;
}
.flexContainer.flexShortHand .flexItem:first-child~*{
    /* flex-grow: 1; flex-basis: 0;  */
    flex-shrink: 1; flex-basis: 150px;
    
}
/* flex-basis : 0 >> auto(자동계산) 취소시키는 의미 */
/* 수축비는 기존 수치가 있어야함
/* 팽창비는 부모를 기준으로 나오는게 당연함. 그러나 얼만큼 따라오는지 ? */

/*
    ? flex-grow(팽창(확장)비):
    ! item의 증가비율을 정한다. default: 0. 즉, 빈 공간을 알아서 확장하여 채우지 않는다.
    ! 음수 비허용. 양수 입력 시 '총 증가 내부팽창지수(grow합산)의 너비중 입력된 비율만큼의 너비를 가진다.
    ! 단, max-width가 설정되면 해당 수치를 넘지 않는다.
    * example. item이 3개이고 item들에게 grow가 1이 부여된다면 각각 1/3(33.33%)의 너비를 갖게 된다.
    ?ex.1 > 만약 전체 너비 (300px)의 item 3개에 개별적으로 grow가 부여되었다면?
    todo. flexItem:first-child{flex-grow:2;} -> 0(basis) + (300/4)*2 = 150.
    todo. flexItem:first-child~*{flex-grow:1;} -> 0(basis) + (300/4)*1 = 75.
    ? why 3(x) 4? = first 2 +  ~* 1 + 1.
*/
/*
    ? flex-shrink(수축비):
    ! 기준되는 부모(절대)가 줄어들 때 item의 수축비를 정한다. default: 1.
    ! 음수 비허용. 양수 입력 시 '총 수축 내부수축지수(shrink합산)의 너비 중 입력된 비율 만큼 수축될 수 있다.
    ! 단, min-width가 설정되면 해당 수치를 넘지 않는다. (basis -> max로 변환 가동)
    * example. item이 3개이고 item들에게 shrink가 1이 부여된다면 각각 1/3의 수축비를 갖게된다.
    ?ex. 2 > 만약 수축중인 부모 너비가 300px인 item 4개(각너비 150px)에  shrink를 부여하면?
    todo. 초과되는 수치인 150 에 대한. shrink총합인 4를 나눈 37.5가 곧 shrink: 1이된다.
    todo. flexItem:first-child{flex-shrink: 2;} -> 150(대상너비) - (150/4)*2 = 75;
    todo. flexItem:first-child~*{flex-shrink: 1;} -> 150(대상너비) - (150/4)*1 = 112.5;
    
    basis:
    !item의 너비를 정한다. 기본값은 auto 이며 다양한 단위 percentages(%) || ems || rems || pixels 를 사용 할 수있다.
    auto : 안의 컨텐츠의 길이만큼 너비가 늘어난다.
*/


